/* tslint:disable */
/* eslint-disable */
/**
 * News Hook API
 * API for monitoring and alerting on news and content updates
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AgentControllerResponse
 */
export interface AgentControllerResponse {
    /**
     * 
     * @type {string}
     * @memberof AgentControllerResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AgentControllerResponse
     */
    'name'?: string | null;
    /**
     * Google\'s unique user ID
     * @type {string}
     * @memberof AgentControllerResponse
     */
    'google_id': string;
    /**
     * 
     * @type {string}
     * @memberof AgentControllerResponse
     */
    'id': string;
    /**
     * API key for authentication
     * @type {string}
     * @memberof AgentControllerResponse
     */
    'api_key': string;
    /**
     * Credits. In cents of USD
     * @type {number}
     * @memberof AgentControllerResponse
     */
    'credit_balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof AgentControllerResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof AgentControllerResponse
     */
    'last_login'?: string | null;
}
/**
 * 
 * @export
 * @interface AlertEventItem
 */
export interface AlertEventItem {
    /**
     * The ID of the alert event
     * @type {string}
     * @memberof AlertEventItem
     */
    'id': string;
    /**
     * The ID of the alert prompt
     * @type {string}
     * @memberof AlertEventItem
     */
    'alert_prompt_id': string;
    /**
     * The datetime the alert event was sent
     * @type {string}
     * @memberof AlertEventItem
     */
    'triggered_at': string;
    /**
     * The json schema requested for the alert
     * @type {{ [key: string]: any; }}
     * @memberof AlertEventItem
     */
    'structured_data': { [key: string]: any; };
    /**
     * The alert prompt that this event answered to
     * @type {string}
     * @memberof AlertEventItem
     */
    'prompt': string;
    /**
     * The HTTP method used at the URL
     * @type {HttpMethod}
     * @memberof AlertEventItem
     */
    'http_method': HttpMethod;
    /**
     * The HTTP URL that the alert event was sent to
     * @type {string}
     * @memberof AlertEventItem
     */
    'http_url': string;
    /**
     * Whether the alert is recurring or not
     * @type {boolean}
     * @memberof AlertEventItem
     */
    'is_recurring': boolean;
}


/**
 * 
 * @export
 * @interface AlertEventListResponse
 */
export interface AlertEventListResponse {
    /**
     * 
     * @type {Array<AlertEventItem>}
     * @memberof AlertEventListResponse
     */
    'events': Array<AlertEventItem>;
    /**
     * 
     * @type {number}
     * @memberof AlertEventListResponse
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface AlertPromptCreateRequestBase
 */
export interface AlertPromptCreateRequestBase {
    /**
     * The description of what to monitor. Try to be specific, clear and succinct.
     * @type {string}
     * @memberof AlertPromptCreateRequestBase
     */
    'prompt': string;
    /**
     * The URL to alert at
     * @type {string}
     * @memberof AlertPromptCreateRequestBase
     */
    'http_url': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AlertPromptCreateRequestBase
     */
    'http_headers'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlertPromptCreateRequestBase
     */
    'is_recurring'?: boolean | null;
    /**
     * 
     * @type {HttpMethod}
     * @memberof AlertPromptCreateRequestBase
     */
    'http_method'?: HttpMethod | null;
    /**
     * 
     * @type {string}
     * @memberof AlertPromptCreateRequestBase
     */
    'llm_model'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AlertPromptCreateRequestBase
     */
    'payload_format'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof AlertPromptCreateRequestBase
     */
    'max_datetime'?: string | null;
}


/**
 * 
 * @export
 * @interface AlertPromptCreateSuccessResponse
 */
export interface AlertPromptCreateSuccessResponse {
    /**
     * The ID of the alert
     * @type {string}
     * @memberof AlertPromptCreateSuccessResponse
     */
    'id': string;
    /**
     * The description of what to monitor
     * @type {string}
     * @memberof AlertPromptCreateSuccessResponse
     */
    'prompt': string;
    /**
     * Reason for the approval or denial
     * @type {string}
     * @memberof AlertPromptCreateSuccessResponse
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof AlertPromptCreateSuccessResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertPromptCreateSuccessResponse
     */
    'keywords'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface AlertPromptItem
 */
export interface AlertPromptItem {
    /**
     * The ID of the alert
     * @type {string}
     * @memberof AlertPromptItem
     */
    'id': string;
    /**
     * The description of what to monitor. Try to be specific, clear and succinct.
     * @type {string}
     * @memberof AlertPromptItem
     */
    'prompt': string;
    /**
     * 
     * @type {HttpMethod}
     * @memberof AlertPromptItem
     */
    'http_method': HttpMethod;
    /**
     * 
     * @type {string}
     * @memberof AlertPromptItem
     */
    'http_url': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AlertPromptItem
     */
    'http_headers'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AlertPromptItem
     */
    'payload_format'?: { [key: string]: any; } | null;
    /**
     * Whether the alert is recurring
     * @type {boolean}
     * @memberof AlertPromptItem
     */
    'is_recurring': boolean;
    /**
     * Tags for hinting
     * @type {Array<string>}
     * @memberof AlertPromptItem
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {AlertStatus}
     * @memberof AlertPromptItem
     */
    'status': AlertStatus;
    /**
     * The date and time the alert was created
     * @type {string}
     * @memberof AlertPromptItem
     */
    'created_at': string;
    /**
     * The date and time the alert will expire
     * @type {string}
     * @memberof AlertPromptItem
     */
    'expires_at': string;
    /**
     * The LLM model used to create the alert
     * @type {string}
     * @memberof AlertPromptItem
     */
    'llm_model': string;
}


/**
 * 
 * @export
 * @interface AlertPromptListResponse
 */
export interface AlertPromptListResponse {
    /**
     * 
     * @type {Array<AlertPromptItem>}
     * @memberof AlertPromptListResponse
     */
    'alerts': Array<AlertPromptItem>;
    /**
     * 
     * @type {number}
     * @memberof AlertPromptListResponse
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AlertStatus = {
    Active: 'ACTIVE',
    Triggered: 'TRIGGERED',
    Cancelled: 'CANCELLED',
    Warned: 'WARNED',
    Expired: 'EXPIRED'
} as const;

export type AlertStatus = typeof AlertStatus[keyof typeof AlertStatus];


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HttpMethod = {
    Post: 'POST',
    Put: 'PUT',
    Patch: 'PATCH'
} as const;

export type HttpMethod = typeof HttpMethod[keyof typeof HttpMethod];


/**
 * 
 * @export
 * @interface LLMModelItem
 */
export interface LLMModelItem {
    /**
     * The name of the LLM model. Vertex-AI refers to it as the model ID.
     * @type {string}
     * @memberof LLMModelItem
     */
    'model_name': string;
    /**
     * Input token price in dollars per million tokens, without cache hit
     * @type {number}
     * @memberof LLMModelItem
     */
    'input_token_price': number;
    /**
     * Output token price in dollars per million tokens, without cache hit
     * @type {number}
     * @memberof LLMModelItem
     */
    'output_token_price': number;
}
/**
 * 
 * @export
 * @interface LLMModelListResponse
 */
export interface LLMModelListResponse {
    /**
     * 
     * @type {Array<LLMModelItem>}
     * @memberof LLMModelListResponse
     */
    'items': Array<LLMModelItem>;
}
/**
 * 
 * @export
 * @interface OAuth2Request
 */
export interface OAuth2Request {
    /**
     * Google OAuth2 access token
     * @type {string}
     * @memberof OAuth2Request
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * JWT access token
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token': string;
    /**
     * Type of token
     * @type {string}
     * @memberof TokenResponse
     */
    'token_type'?: string;
    /**
     * Token expiration time
     * @type {string}
     * @memberof TokenResponse
     */
    'expires_in': string;
    /**
     * 
     * @type {AgentControllerResponse}
     * @memberof TokenResponse
     */
    'agent_controller': AgentControllerResponse;
}
/**
 * 
 * @export
 * @interface UserDocumentCreateRequest
 */
export interface UserDocumentCreateRequest {
    /**
     * The name of the document
     * @type {string}
     * @memberof UserDocumentCreateRequest
     */
    'name': string;
    /**
     * The actual content of the document
     * @type {string}
     * @memberof UserDocumentCreateRequest
     */
    'content': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDocumentCreateRequest
     */
    'should_save'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UserDocumentCreateSuccessResponse
 */
export interface UserDocumentCreateSuccessResponse {
    /**
     * The id of the document
     * @type {string}
     * @memberof UserDocumentCreateSuccessResponse
     */
    'id': string;
    /**
     * The name of the document
     * @type {string}
     * @memberof UserDocumentCreateSuccessResponse
     */
    'name': string;
    /**
     * The date and time the document was created
     * @type {string}
     * @memberof UserDocumentCreateSuccessResponse
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface UserDocumentItem
 */
export interface UserDocumentItem {
    /**
     * The id of the document
     * @type {string}
     * @memberof UserDocumentItem
     */
    'id': string;
    /**
     * The name of the document
     * @type {string}
     * @memberof UserDocumentItem
     */
    'name': string;
    /**
     * The content of the document itself. Limit of 2048 tokens.
     * @type {string}
     * @memberof UserDocumentItem
     */
    'content': string;
    /**
     * The date and time the document was uploaded by the user
     * @type {string}
     * @memberof UserDocumentItem
     */
    'uploaded_at': string;
}
/**
 * 
 * @export
 * @interface UserDocumentListResponse
 */
export interface UserDocumentListResponse {
    /**
     * 
     * @type {Array<UserDocumentItem>}
     * @memberof UserDocumentListResponse
     */
    'documents': Array<UserDocumentItem>;
    /**
     * 
     * @type {number}
     * @memberof UserDocumentListResponse
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Mark an alert as CANCELLED. We do not \'delete\' the alert, for billing purposes
         * @summary Cancel Alert
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelAlertApiV1AlertsAlertIdCancelPatch: async (alertId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('cancelAlertApiV1AlertsAlertIdCancelPatch', 'alertId', alertId)
            const localVarPath = `/api/v1/alerts/{alert_id}/cancel`
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new alert for monitoring
         * @summary Create Alert
         * @param {AlertPromptCreateRequestBase} alertPromptCreateRequestBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertApiV1AlertsPost: async (alertPromptCreateRequestBase: AlertPromptCreateRequestBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertPromptCreateRequestBase' is not null or undefined
            assertParamExists('createAlertApiV1AlertsPost', 'alertPromptCreateRequestBase', alertPromptCreateRequestBase)
            const localVarPath = `/api/v1/alerts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertPromptCreateRequestBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific alert by ID
         * @summary Get Alert
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertApiV1AlertsAlertIdGet: async (alertId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('getAlertApiV1AlertsAlertIdGet', 'alertId', alertId)
            const localVarPath = `/api/v1/alerts/{alert_id}`
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alerts for the authenticated user with filtering and pagination
         * @summary List Alerts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [promptContains] 
         * @param {string | null} [maxDatetime] 
         * @param {string | null} [createdAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertsApiV1AlertsGet: async (offset?: number, limit?: number, promptContains?: string | null, maxDatetime?: string | null, createdAfter?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alerts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (promptContains !== undefined) {
                localVarQueryParameter['prompt_contains'] = promptContains;
            }

            if (maxDatetime !== undefined) {
                localVarQueryParameter['max_datetime'] = (maxDatetime as any instanceof Date) ?
                    (maxDatetime as any).toISOString() :
                    maxDatetime;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * Mark an alert as CANCELLED. We do not \'delete\' the alert, for billing purposes
         * @summary Cancel Alert
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelAlertApiV1AlertsAlertIdCancelPatch(alertId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelAlertApiV1AlertsAlertIdCancelPatch(alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.cancelAlertApiV1AlertsAlertIdCancelPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new alert for monitoring
         * @summary Create Alert
         * @param {AlertPromptCreateRequestBase} alertPromptCreateRequestBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertApiV1AlertsPost(alertPromptCreateRequestBase: AlertPromptCreateRequestBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertPromptCreateSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertApiV1AlertsPost(alertPromptCreateRequestBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.createAlertApiV1AlertsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific alert by ID
         * @summary Get Alert
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertApiV1AlertsAlertIdGet(alertId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertPromptItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertApiV1AlertsAlertIdGet(alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.getAlertApiV1AlertsAlertIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all alerts for the authenticated user with filtering and pagination
         * @summary List Alerts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [promptContains] 
         * @param {string | null} [maxDatetime] 
         * @param {string | null} [createdAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertsApiV1AlertsGet(offset?: number, limit?: number, promptContains?: string | null, maxDatetime?: string | null, createdAfter?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertPromptListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertsApiV1AlertsGet(offset, limit, promptContains, maxDatetime, createdAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.listAlertsApiV1AlertsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * Mark an alert as CANCELLED. We do not \'delete\' the alert, for billing purposes
         * @summary Cancel Alert
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelAlertApiV1AlertsAlertIdCancelPatch(alertId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.cancelAlertApiV1AlertsAlertIdCancelPatch(alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new alert for monitoring
         * @summary Create Alert
         * @param {AlertPromptCreateRequestBase} alertPromptCreateRequestBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertApiV1AlertsPost(alertPromptCreateRequestBase: AlertPromptCreateRequestBase, options?: RawAxiosRequestConfig): AxiosPromise<AlertPromptCreateSuccessResponse> {
            return localVarFp.createAlertApiV1AlertsPost(alertPromptCreateRequestBase, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific alert by ID
         * @summary Get Alert
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertApiV1AlertsAlertIdGet(alertId: string, options?: RawAxiosRequestConfig): AxiosPromise<AlertPromptItem> {
            return localVarFp.getAlertApiV1AlertsAlertIdGet(alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alerts for the authenticated user with filtering and pagination
         * @summary List Alerts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [promptContains] 
         * @param {string | null} [maxDatetime] 
         * @param {string | null} [createdAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertsApiV1AlertsGet(offset?: number, limit?: number, promptContains?: string | null, maxDatetime?: string | null, createdAfter?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AlertPromptListResponse> {
            return localVarFp.listAlertsApiV1AlertsGet(offset, limit, promptContains, maxDatetime, createdAfter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * Mark an alert as CANCELLED. We do not \'delete\' the alert, for billing purposes
     * @summary Cancel Alert
     * @param {string} alertId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public cancelAlertApiV1AlertsAlertIdCancelPatch(alertId: string, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).cancelAlertApiV1AlertsAlertIdCancelPatch(alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new alert for monitoring
     * @summary Create Alert
     * @param {AlertPromptCreateRequestBase} alertPromptCreateRequestBase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public createAlertApiV1AlertsPost(alertPromptCreateRequestBase: AlertPromptCreateRequestBase, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).createAlertApiV1AlertsPost(alertPromptCreateRequestBase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific alert by ID
     * @summary Get Alert
     * @param {string} alertId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAlertApiV1AlertsAlertIdGet(alertId: string, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getAlertApiV1AlertsAlertIdGet(alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all alerts for the authenticated user with filtering and pagination
     * @summary List Alerts
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [promptContains] 
     * @param {string | null} [maxDatetime] 
     * @param {string | null} [createdAfter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public listAlertsApiV1AlertsGet(offset?: number, limit?: number, promptContains?: string | null, maxDatetime?: string | null, createdAfter?: string | null, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).listAlertsApiV1AlertsGet(offset, limit, promptContains, maxDatetime, createdAfter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the current user\'s credit balance.
         * @summary Check Credits
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCreditsApiV1AuthCreditsGet: async (authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user account and all associated data (alert prompts)
         * @summary Delete Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountApiV1AuthAccountDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login using Google OAuth2 token.
         * @summary Login
         * @param {OAuth2Request} oAuth2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginApiV1AuthLoginPost: async (oAuth2Request: OAuth2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuth2Request' is not null or undefined
            assertParamExists('loginApiV1AuthLoginPost', 'oAuth2Request', oAuth2Request)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuth2Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign up a new user using Google OAuth2 token.
         * @summary Signup
         * @param {OAuth2Request} oAuth2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupApiV1AuthSignupPost: async (oAuth2Request: OAuth2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuth2Request' is not null or undefined
            assertParamExists('signupApiV1AuthSignupPost', 'oAuth2Request', oAuth2Request)
            const localVarPath = `/api/v1/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuth2Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the current user\'s credit balance.
         * @summary Check Credits
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkCreditsApiV1AuthCreditsGet(authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkCreditsApiV1AuthCreditsGet(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.checkCreditsApiV1AuthCreditsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user account and all associated data (alert prompts)
         * @summary Delete Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountApiV1AuthAccountDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountApiV1AuthAccountDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.deleteAccountApiV1AuthAccountDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login using Google OAuth2 token.
         * @summary Login
         * @param {OAuth2Request} oAuth2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginApiV1AuthLoginPost(oAuth2Request: OAuth2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginApiV1AuthLoginPost(oAuth2Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginApiV1AuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sign up a new user using Google OAuth2 token.
         * @summary Signup
         * @param {OAuth2Request} oAuth2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupApiV1AuthSignupPost(oAuth2Request: OAuth2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupApiV1AuthSignupPost(oAuth2Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signupApiV1AuthSignupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Get the current user\'s credit balance.
         * @summary Check Credits
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCreditsApiV1AuthCreditsGet(authorization?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.checkCreditsApiV1AuthCreditsGet(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user account and all associated data (alert prompts)
         * @summary Delete Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountApiV1AuthAccountDelete(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteAccountApiV1AuthAccountDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Login using Google OAuth2 token.
         * @summary Login
         * @param {OAuth2Request} oAuth2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginApiV1AuthLoginPost(oAuth2Request: OAuth2Request, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.loginApiV1AuthLoginPost(oAuth2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Sign up a new user using Google OAuth2 token.
         * @summary Signup
         * @param {OAuth2Request} oAuth2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupApiV1AuthSignupPost(oAuth2Request: OAuth2Request, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.signupApiV1AuthSignupPost(oAuth2Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Get the current user\'s credit balance.
     * @summary Check Credits
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public checkCreditsApiV1AuthCreditsGet(authorization?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).checkCreditsApiV1AuthCreditsGet(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user account and all associated data (alert prompts)
     * @summary Delete Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteAccountApiV1AuthAccountDelete(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteAccountApiV1AuthAccountDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login using Google OAuth2 token.
     * @summary Login
     * @param {OAuth2Request} oAuth2Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginApiV1AuthLoginPost(oAuth2Request: OAuth2Request, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginApiV1AuthLoginPost(oAuth2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign up a new user using Google OAuth2 token.
     * @summary Signup
     * @param {OAuth2Request} oAuth2Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signupApiV1AuthSignupPost(oAuth2Request: OAuth2Request, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signupApiV1AuthSignupPost(oAuth2Request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthCheckHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all events for the authenticated user with filtering and pagination
         * @summary List Events
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [triggeredBefore] 
         * @param {string | null} [triggeredAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsApiV1EventsGet: async (offset?: number, limit?: number, triggeredBefore?: string | null, triggeredAfter?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (triggeredBefore !== undefined) {
                localVarQueryParameter['triggered_before'] = (triggeredBefore as any instanceof Date) ?
                    (triggeredBefore as any).toISOString() :
                    triggeredBefore;
            }

            if (triggeredAfter !== undefined) {
                localVarQueryParameter['triggered_after'] = (triggeredAfter as any instanceof Date) ?
                    (triggeredAfter as any).toISOString() :
                    triggeredAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all events for the authenticated user with filtering and pagination
         * @summary List Events
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [triggeredBefore] 
         * @param {string | null} [triggeredAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventsApiV1EventsGet(offset?: number, limit?: number, triggeredBefore?: string | null, triggeredAfter?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertEventListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventsApiV1EventsGet(offset, limit, triggeredBefore, triggeredAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.listEventsApiV1EventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * List all events for the authenticated user with filtering and pagination
         * @summary List Events
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [triggeredBefore] 
         * @param {string | null} [triggeredAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsApiV1EventsGet(offset?: number, limit?: number, triggeredBefore?: string | null, triggeredAfter?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AlertEventListResponse> {
            return localVarFp.listEventsApiV1EventsGet(offset, limit, triggeredBefore, triggeredAfter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * List all events for the authenticated user with filtering and pagination
     * @summary List Events
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [triggeredBefore] 
     * @param {string | null} [triggeredAfter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEventsApiV1EventsGet(offset?: number, limit?: number, triggeredBefore?: string | null, triggeredAfter?: string | null, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEventsApiV1EventsGet(offset, limit, triggeredBefore, triggeredAfter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LlmModelsApi - axios parameter creator
 * @export
 */
export const LlmModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all active LLM models.
         * @summary List Llm Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLlmModelsApiV1LlmModelsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/llm-models/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LlmModelsApi - functional programming interface
 * @export
 */
export const LlmModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LlmModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all active LLM models.
         * @summary List Llm Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLlmModelsApiV1LlmModelsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LLMModelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLlmModelsApiV1LlmModelsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LlmModelsApi.listLlmModelsApiV1LlmModelsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LlmModelsApi - factory interface
 * @export
 */
export const LlmModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LlmModelsApiFp(configuration)
    return {
        /**
         * List all active LLM models.
         * @summary List Llm Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLlmModelsApiV1LlmModelsGet(options?: RawAxiosRequestConfig): AxiosPromise<LLMModelListResponse> {
            return localVarFp.listLlmModelsApiV1LlmModelsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LlmModelsApi - object-oriented interface
 * @export
 * @class LlmModelsApi
 * @extends {BaseAPI}
 */
export class LlmModelsApi extends BaseAPI {
    /**
     * List all active LLM models.
     * @summary List Llm Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LlmModelsApi
     */
    public listLlmModelsApiV1LlmModelsGet(options?: RawAxiosRequestConfig) {
        return LlmModelsApiFp(this.configuration).listLlmModelsApiV1LlmModelsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserDocumentsApi - axios parameter creator
 * @export
 */
export const UserDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a document by ID
         * @summary Get User Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDocumentApiV1UserDocumentsDocumentIdGet: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getUserDocumentApiV1UserDocumentsDocumentIdGet', 'documentId', documentId)
            const localVarPath = `/api/v1/user_documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all documents for the authenticated user. Can filter by substrings in the name or content.
         * @summary Get User Documents
         * @param {string | null} [contains] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDocumentsApiV1UserDocumentsGet: async (contains?: string | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user_documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (contains !== undefined) {
                localVarQueryParameter['contains'] = contains;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin documents
         * @summary Post Admin Document
         * @param {UserDocumentCreateRequest} userDocumentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminDocumentApiV1UserDocumentsManualPost: async (userDocumentCreateRequest: UserDocumentCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userDocumentCreateRequest' is not null or undefined
            assertParamExists('postAdminDocumentApiV1UserDocumentsManualPost', 'userDocumentCreateRequest', userDocumentCreateRequest)
            const localVarPath = `/api/v1/user_documents/manual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userDocumentCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document
         * @summary Post User Document
         * @param {UserDocumentCreateRequest} userDocumentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserDocumentApiV1UserDocumentsPost: async (userDocumentCreateRequest: UserDocumentCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userDocumentCreateRequest' is not null or undefined
            assertParamExists('postUserDocumentApiV1UserDocumentsPost', 'userDocumentCreateRequest', userDocumentCreateRequest)
            const localVarPath = `/api/v1/user_documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userDocumentCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserDocumentsApi - functional programming interface
 * @export
 */
export const UserDocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserDocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a document by ID
         * @summary Get User Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDocumentApiV1UserDocumentsDocumentIdGet(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDocumentItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDocumentApiV1UserDocumentsDocumentIdGet(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserDocumentsApi.getUserDocumentApiV1UserDocumentsDocumentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all documents for the authenticated user. Can filter by substrings in the name or content.
         * @summary Get User Documents
         * @param {string | null} [contains] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDocumentsApiV1UserDocumentsGet(contains?: string | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDocumentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDocumentsApiV1UserDocumentsGet(contains, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserDocumentsApi.getUserDocumentsApiV1UserDocumentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin documents
         * @summary Post Admin Document
         * @param {UserDocumentCreateRequest} userDocumentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAdminDocumentApiV1UserDocumentsManualPost(userDocumentCreateRequest: UserDocumentCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDocumentCreateSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAdminDocumentApiV1UserDocumentsManualPost(userDocumentCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserDocumentsApi.postAdminDocumentApiV1UserDocumentsManualPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document
         * @summary Post User Document
         * @param {UserDocumentCreateRequest} userDocumentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserDocumentApiV1UserDocumentsPost(userDocumentCreateRequest: UserDocumentCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDocumentCreateSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserDocumentApiV1UserDocumentsPost(userDocumentCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserDocumentsApi.postUserDocumentApiV1UserDocumentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserDocumentsApi - factory interface
 * @export
 */
export const UserDocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserDocumentsApiFp(configuration)
    return {
        /**
         * Get a document by ID
         * @summary Get User Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDocumentApiV1UserDocumentsDocumentIdGet(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDocumentItem> {
            return localVarFp.getUserDocumentApiV1UserDocumentsDocumentIdGet(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all documents for the authenticated user. Can filter by substrings in the name or content.
         * @summary Get User Documents
         * @param {string | null} [contains] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDocumentsApiV1UserDocumentsGet(contains?: string | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserDocumentListResponse> {
            return localVarFp.getUserDocumentsApiV1UserDocumentsGet(contains, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin documents
         * @summary Post Admin Document
         * @param {UserDocumentCreateRequest} userDocumentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAdminDocumentApiV1UserDocumentsManualPost(userDocumentCreateRequest: UserDocumentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDocumentCreateSuccessResponse> {
            return localVarFp.postAdminDocumentApiV1UserDocumentsManualPost(userDocumentCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document
         * @summary Post User Document
         * @param {UserDocumentCreateRequest} userDocumentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserDocumentApiV1UserDocumentsPost(userDocumentCreateRequest: UserDocumentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDocumentCreateSuccessResponse> {
            return localVarFp.postUserDocumentApiV1UserDocumentsPost(userDocumentCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserDocumentsApi - object-oriented interface
 * @export
 * @class UserDocumentsApi
 * @extends {BaseAPI}
 */
export class UserDocumentsApi extends BaseAPI {
    /**
     * Get a document by ID
     * @summary Get User Document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDocumentsApi
     */
    public getUserDocumentApiV1UserDocumentsDocumentIdGet(documentId: string, options?: RawAxiosRequestConfig) {
        return UserDocumentsApiFp(this.configuration).getUserDocumentApiV1UserDocumentsDocumentIdGet(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all documents for the authenticated user. Can filter by substrings in the name or content.
     * @summary Get User Documents
     * @param {string | null} [contains] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDocumentsApi
     */
    public getUserDocumentsApiV1UserDocumentsGet(contains?: string | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return UserDocumentsApiFp(this.configuration).getUserDocumentsApiV1UserDocumentsGet(contains, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin documents
     * @summary Post Admin Document
     * @param {UserDocumentCreateRequest} userDocumentCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDocumentsApi
     */
    public postAdminDocumentApiV1UserDocumentsManualPost(userDocumentCreateRequest: UserDocumentCreateRequest, options?: RawAxiosRequestConfig) {
        return UserDocumentsApiFp(this.configuration).postAdminDocumentApiV1UserDocumentsManualPost(userDocumentCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document
     * @summary Post User Document
     * @param {UserDocumentCreateRequest} userDocumentCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDocumentsApi
     */
    public postUserDocumentApiV1UserDocumentsPost(userDocumentCreateRequest: UserDocumentCreateRequest, options?: RawAxiosRequestConfig) {
        return UserDocumentsApiFp(this.configuration).postUserDocumentApiV1UserDocumentsPost(userDocumentCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



